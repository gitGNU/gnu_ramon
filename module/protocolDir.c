/*
 * Ramon - A RMON2 Network Monitoring Agent
 * Copyright (C) 2003 Ricardo Nabinger Sanchez
 *
 * This file is part of Ramon, a network monitoring agent which implements
 * the MIB proposed in RFC-2021.
 *
 * Ramon is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * Ramon is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with program; see the file COPYING. If not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 5.5 2002/12/16 22:50:18 hardaker Exp $
 */

/** \file protocolDir.c
 * \brief Integrates RMON2 protocolDir group into Net-SNMP
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "protocolDir.h"

#include "configuracao.h"

#if PTSL
#include <pthread.h>
#include <netinet/in.h>
#include "pedb.h"
#include "tracos.h"
#include "servidor.h"
#endif
/* XXX: stateful.h is being included anyway, to avoid ifdef flood. */
#include "stateful.h"

#include "protocoldir.h"
#include "exit_codes.h"


#if PTSL
static pthread_t thr_servidor;
#endif


/** \brief Initialize the protocolDirTable table by defining its contents and
 * how it's structured.
 */
void
initialize_table_protocolDirTable(void)
{
    static oid	protocolDirTable_oid[] = { 1, 3, 6, 1, 2, 1, 16, 11, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration    *my_handler;
    netsnmp_iterator_info	    *iinfo;

    /*
     * create the table structure itself
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
     */
    my_handler = netsnmp_create_handler_registration("protocolDirTable",
                                                     protocolDirTable_handler,
                                                     protocolDirTable_oid,
                                                     OID_LENGTH(protocolDirTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR, /* index: protocolDirID */
                                     ASN_OCTET_STR,     /* index: protocolDirParameters */
                                     0);

    table_info->min_column = 3;
    table_info->max_column = 10;

    /*
     * iterator access routines
     */
    iinfo->get_first_data_point = protocolDirTable_get_first_data_point;
    iinfo->get_next_data_point = protocolDirTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_protocolDirTable",
                "Registering table protocolDirTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}


/** \brief Initializes the protocolDir module.
 */
void
init_protocolDir(void)
{

    /*
     * here we initialize all the tables we're planning on supporting
     */
    if (init_protocoldir(NULL) != SUCCESS) {
	snmp_log(LOG_ERR, "error while initializing protocolDir table\n");
	return;
    }

#if PTSL
    if (pthread_create(&thr_servidor, NULL, server_start, NULL) != 0) {
	snmp_log(LOG_ERR, "protocolDir: error while launching PTSL server\n");
	return;
    }
#endif

    initialize_table_protocolDirTable();

    snmp_log(LOG_INFO, "success: protocolDir initialized\n");
}


/** returns the first data point within the protocolDirTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.

    \bug    if the first entry is a protocol trace, which is an error,
	    this will fail (possibly crashing Net-SNMP).
*/
netsnmp_variable_list *
protocolDirTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    unsigned char	    index_str_id[17] = {0, };
    unsigned char	    index_str_p[5] = {0, };
    netsnmp_variable_list   *vptr;
    uint32_t		    indice;	    /* o indice no vetor */
    unsigned int	    tamanho_id;	    /* tamanho do id{link,net,transp,app} */
    unsigned int	    tamanho_p;	    /* tamanho dos params */

    if (pdir_tabela_primeiro(&indice) != SUCCESS) {
	/* erro ou sem elementos */
	snmp_log(LOG_ERR, "protocolDirTable: no entries???\n");
	return NULL;
    }

    tamanho_id = pdir_busca_id_octetstring(indice, index_str_id, sizeof(index_str_id));
    tamanho_p = pdir_busca_param_octetstring(indice, index_str_p, sizeof(index_str_p));

    if ((tamanho_id == 0) || (tamanho_p == 0)){
	snmp_log(LOG_ERR, "protocolDirTable: error while creating index octet string\n");
	return NULL;
    }

#if PTSL
    if (pdir_possui_traco(indice) > 0) {
	*my_loop_context = (void *)indice;
    }
    else {
	*my_loop_context = (void *)0;
    }
#else
    *my_loop_context = (void *)indice;
#endif

    *my_data_context = (void *)indice;

    vptr = put_index_data;
    snmp_set_var_value(vptr, (u_char *)index_str_id, tamanho_id);
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)index_str_p, tamanho_p);
    vptr = vptr->next_variable;

    return put_index_data;
}


/** functionally the same as protocolDirTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again.
 */
netsnmp_variable_list *
protocolDirTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    unsigned char	    index_str_id[17];
    unsigned char	    index_str_p[5];
    netsnmp_variable_list   *vptr;
    uint32_t		    indice;	    /* o indice no vetor */
    uint32_t		    data;
    unsigned int	    tamanho_id;	    /* tamanho do id{link,net,transp,app} */
    unsigned int	    tamanho_p;	    /* tamanho dos params */

#if PTSL
    indice = (uint32_t)(*my_loop_context);
    data = (uint32_t)(*my_data_context);

    /* FIXME retirar o debug. */
//    fprintf(stderr, "indice: %u, data: %u\n", indice, data);

    if (indice == 0) {
	if (pdir_tabela_proximo(&indice) != SUCCESS) {
	    /* erro ou sem elementos */
	    return NULL;
	}
	/* FIXME retirar o debug. */
//	fprintf(stderr, "Indice era 0, novo indice = %u.\n", indice);

	tamanho_id = pdir_busca_id_octetstring(indice, index_str_id, sizeof(index_str_id));

	if (tamanho_id == 0) {
	    snmp_log(LOG_ERR, "protocolDirTable: error while creating index octet string\n");
	    return NULL;
	}

	if (pdir_possui_traco(indice) > 0) {
	    *my_loop_context = (void *)indice;
	}
	else {
	    *my_loop_context = (void *)0;
	}

	*my_data_context = (void *)indice;
    }
    else {
	if (indice == data) {
	    data = (uint32_t)pdir_primeiro_traco(indice);
	}
	else {
	    data = (uint32_t)((traco_t *)data)->proximo_traco;
	    if (!data) {
		if (pdir_tabela_proximo(&indice) != SUCCESS) {
		    /* erro ou sem elementos */
		    return NULL;
		}

		tamanho_id = pdir_busca_id_octetstring(indice, index_str_id, sizeof(index_str_id));

		if (tamanho_id == 0){
		    snmp_log(LOG_ERR, "protocolDirTable: error while creating index octet string\n");
		    return NULL;
		}

		if (pdir_possui_traco(indice) > 0) {
		    *my_loop_context = (void *)indice;
		}
		else {
		    *my_loop_context = (void *)0;
		}

		*my_data_context = (void *)indice;
		goto get_param;
	    }
	}

	tamanho_id = pdir_traco_busca_idstring((traco_t *)data, index_str_id, sizeof(index_str_id));
	if (tamanho_id == 0) {
	    snmp_log(LOG_ERR, "protocolDir: error while fetching index string\n");
	}
	/* FIXME retirar o debug. */
//	fprintf(stderr, "idstring: %u %u.%u.%u.%u %u.%u.%u.%u %u.%u.%u.%u %u.%u.%u.%u\n",
//		index_str_id[0], index_str_id[1], index_str_id[2], index_str_id[3], index_str_id[4],
//		index_str_id[5], index_str_id[6], index_str_id[7], index_str_id[8], index_str_id[9],
//		index_str_id[10], index_str_id[11], index_str_id[12], index_str_id[13], index_str_id[14],
//		index_str_id[15], index_str_id[16]);

	*my_data_context = (void *)data;
    }

get_param:
    tamanho_p = pdir_busca_param_octetstring(indice, index_str_p, sizeof(index_str_p));
    if (tamanho_p == 0){
	snmp_log(LOG_ERR, "protocolDirTable: error while creating index octet string\n");
	return NULL;
    }
#else
    if (pdir_tabela_proximo(&indice) != SUCCESS) {
	/* erro ou sem elementos */
	return NULL;
    }

    tamanho_id = pdir_busca_id_octetstring(indice, index_str_id, sizeof(index_str_id));
    tamanho_p = pdir_busca_param_octetstring(indice, index_str_p, sizeof(index_str_p));

    if ((tamanho_id == 0) || (tamanho_p == 0)){
	snmp_log(LOG_ERR, "protocolDirTable: error while creating index octet string\n");
	return NULL;
    }

    *my_loop_context = (void *)indice;
    *my_data_context = (void *)indice;
#endif

    vptr = put_index_data;
    snmp_set_var_value(vptr, index_str_id, tamanho_id);
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, index_str_p, tamanho_p);
    vptr = vptr->next_variable;

    return put_index_data;
}


/** \brief Handles requests for the protocolDirTable table, if anything else
 * needs to be done.
 */
int
protocolDirTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    unsigned char		char_buffer[64];    /* to copy strings */
    netsnmp_request_info	*request;
    netsnmp_table_request_info	*table_info;
    netsnmp_variable_list	*var;
    uint32_t			valor;
    unsigned int		indice;
    int				tamanho;
    unsigned char		char_u;
    traco_t			*traco_ptr;


    /* FIXME retirar essa toskice!! */
//    fprintf(stderr, "	    Entrou no protocolDirTable\n");

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0) {
            continue;
	}

        /*
         * perform anything here that you need to do before each
         * request is processed.
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the protocolDirTable table in question
         */
	indice = (uint32_t)netsnmp_extract_iterator_context(request);
	fprintf(stderr, "table_handler: %u\n", indice);

	if (indice < 6000) {
	    traco_ptr = NULL;
	    if (pdir_tabela_testa(indice) != SUCCESS) {
		if (reqinfo->mode == MODE_GET) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
		    continue;
		}
		/*
		 * XXX: no row existed, if you support creation and this is a
		 * set, start dealing with it here, else continue
		 */
	    }
	}
	else {
	    /* FIXME: incluir uma verificacao de erro aqui */
	    traco_ptr = (traco_t *)indice;
	    fprintf(stderr, "traco_ptr = %p\n", traco_ptr);
	}

        /*
         * extracts the information about the table from the request
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_PROTOCOLDIRLOCALINDEX:
		/* REALLY ugly hack (the hardcoded number!) */
		if (traco_ptr == NULL) {
		    if (pdir_tabela_busca_localindex(indice, &valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_localindex(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		else {
//		    if (pdir_traco_localindex(((traco_t *)indice)->pdir_index,
//				&valor) != SUCCESS) {
//			snmp_log(LOG_ERR, "pdir_tabela_busca_localindex(%u, *) falhou\n", indice);
//			return SNMP_ERR_NOSUCHNAME;
//		    }
		    valor = traco_ptr->pdir_localindex;
		}
                snmp_set_var_typed_value(var, ASN_INTEGER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_PROTOCOLDIRDESCR:
    //		fprintf(stderr, "protocolDir: [descr] %p\n", traco_ptr);
		if (traco_ptr == NULL) {
		    tamanho = pdir_tabela_busca_descr(indice, char_buffer, sizeof(char_buffer));
		    if (tamanho > 0) {
			/* success */
			snmp_set_var_typed_value(var, ASN_OCTET_STR, (u_char *)char_buffer, tamanho);
		    }
		    else {
			snmp_log(LOG_ERR, "pdir_tabela_busca_descr(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		else {
		    tamanho = strlen(traco_ptr->descricao->descricao);
		    if (tamanho > sizeof(char_buffer)) {
			tamanho = sizeof(char_buffer);
		    }
		    strncpy(char_buffer, traco_ptr->descricao->descricao, tamanho);

		    fprintf(stderr, "protocolDir: descr(%u) = '%s'\n", tamanho, traco_ptr->descricao->descricao);

		    if (tamanho > 0) {
			/* success */
			snmp_set_var_typed_value(var, ASN_OCTET_STR, char_buffer, tamanho);
		    }
		    else {
			snmp_log(LOG_ERR, "protocolDir: empty description string\n");
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		break;

            case COLUMN_PROTOCOLDIRTYPE:
		if (traco_ptr == NULL) {
		    if (pdir_tabela_busca_tipo(indice, &char_u) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_tipo(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		else {
		    if (pdir_tabela_busca_tipo(traco_ptr->pdir_index, &char_u) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_tipo(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
                snmp_set_var_typed_value(var, ASN_OCTET_STR, (u_char *)&char_u, sizeof(char_u));
                break;

            case COLUMN_PROTOCOLDIRADDRESSMAPCONFIG:
		if (traco_ptr == NULL) {
		    if (pdir_tabela_busca_addrmapconfig(indice, &valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_addrmapconfig(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		else {
		    if (pdir_tabela_busca_addrmapconfig(traco_ptr->pdir_index, &valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_addrmapconfig(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		snmp_set_var_typed_value(var, ASN_INTEGER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_PROTOCOLDIRHOSTCONFIG:
		if (indice < 6000) {
		    if (pdir_tabela_busca_hostconfig(indice, &valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_hostconfig(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		else {
		    if (pdir_tabela_busca_hostconfig(((traco_t *)indice)->pdir_index,
				&valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_hostconfig(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		snmp_set_var_typed_value(var, ASN_INTEGER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_PROTOCOLDIRMATRIXCONFIG:
		if (indice < 6000) {
		    if (pdir_tabela_busca_matrixconfig(indice, &valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_matrix_hostconfig(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		else {
		    if (pdir_tabela_busca_matrixconfig(((traco_t *)indice)->pdir_index,
				&valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_matrix_hostconfig(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		snmp_set_var_typed_value(var, ASN_INTEGER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_PROTOCOLDIROWNER:
		if (traco_ptr == NULL) {
		    tamanho = pdir_tabela_busca_owner(indice, char_buffer, sizeof(char_buffer));
		    if (tamanho > 0) {
			/* success */
			snmp_set_var_typed_value(var, ASN_OCTET_STR, (u_char *)char_buffer, tamanho);
		    }
		    else {
			snmp_log(LOG_ERR, "pdir_tabela_busca_owner(%u, ...) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		else {
		    tamanho = strlen(traco_ptr->descricao->criador);
		    if (tamanho > sizeof(char_buffer)) {
			tamanho = sizeof(char_buffer);
		    }
		    strncpy(char_buffer, traco_ptr->descricao->criador, tamanho);
		    if (tamanho > 0) {
			/* success */
			snmp_set_var_typed_value(var, ASN_OCTET_STR, char_buffer, tamanho);
		    }
		    else {
			snmp_log(LOG_ERR, "protocolDir: empty owner string\n");
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		break;

            case COLUMN_PROTOCOLDIRSTATUS:
		if (indice < 6000) {
		    if (pdir_tabela_busca_status(indice, &valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_status(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
  		}
		else {
		    if (pdir_tabela_busca_status(((traco_t *)indice)->pdir_index, &valor) != SUCCESS) {
			snmp_log(LOG_ERR, "pdir_tabela_busca_status(%u, *) falhou\n", indice);
			return SNMP_ERR_NOSUCHNAME;
		    }
		}
		snmp_set_var_typed_value(var, ASN_INTEGER, (u_char *)&valor, sizeof(valor));
                break;

            default:
                /*
                 * We shouldn't get here
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in protocolDirTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling...
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in protocolDirTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

