/*
 * Ramon - A RMON2 Network Monitoring Agent
 * Copyright (C) 2003 Ricardo Nabinger Sanchez
 *
 * This file is part of Ramon, a network monitoring agent which implements
 * the MIB proposed in RFC-2021.
 *
 * Ramon is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * Ramon is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with program; see the file COPYING. If not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 5.5 2002/12/16 22:50:18 hardaker Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "nlMatrix.h"

#include "hlmatrix.h"
#include "nlmatrix_DS.h"
#include "nlmatrix_SD.h"
#include "exit_codes.h"


/** Initialize the hlMatrixControlTable table by defining its contents and how it's structured */
void
initialize_table_hlMatrixControlTable(void)
{
    static oid hlMatrixControlTable_oid[] = { 1, 3, 6, 1, 2, 1, 16, 15, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration    *my_handler;
    netsnmp_iterator_info	    *iinfo;

    /*
     * create the table structure itself
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
     */
    my_handler =
        netsnmp_create_handler_registration("hlMatrixControlTable",
                                            hlMatrixControlTable_handler,
                                            hlMatrixControlTable_oid,
                                            OID_LENGTH(hlMatrixControlTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hlMatrixControlIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 12;

    /*
     * iterator access routines
     */
    iinfo->get_first_data_point =
        hlMatrixControlTable_get_first_data_point;
    iinfo->get_next_data_point = hlMatrixControlTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_hlMatrixControlTable",
                "Registering table hlMatrixControlTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);

    snmp_log(LOG_INFO, "success: hlMatrix initialized\n");
}


/** Initialize the nlMatrixDSTable table by defining its contents and how it's structured */
void
initialize_table_nlMatrixDSTable(void)
{
    static oid nlMatrixDSTable_oid[] = { 1, 3, 6, 1, 2, 1, 16, 15, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration    *my_handler;
    netsnmp_iterator_info	    *iinfo;

    /*
     * create the table structure itself
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
     */
    my_handler = netsnmp_create_handler_registration("nlMatrixDSTable",
                                                     nlMatrixDSTable_handler,
                                                     nlMatrixDSTable_oid,
                                                     OID_LENGTH(nlMatrixDSTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
				     ASN_INTEGER,   /* index: hlMatrixControlIndex */
                                     ASN_TIMETICKS,     /* index: nlMatrixDSTimeMark */
                                     ASN_INTEGER,       /* index: protocolDirLocalIndex */
                                     ASN_OCTET_STR,     /* index: nlMatrixDSDestAddress */
                                     ASN_OCTET_STR,     /* index: nlMatrixDSSourceAddress */
                                     0);

    table_info->min_column = 4;
    table_info->max_column = 6;

    /*
     * iterator access routines
     */
    iinfo->get_first_data_point = nlMatrixDSTable_get_first_data_point;
    iinfo->get_next_data_point = nlMatrixDSTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_nlMatrixDSTable",
                "Registering table nlMatrixDSTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);

    snmp_log(LOG_INFO, "success: nlMatrixDS initialized\n");
}


/** Initialize the nlMatrixTopNTable table by defining its contents and how it's structured */
void
initialize_table_nlMatrixTopNTable(void)
{
#if 0
    static oid nlMatrixTopNTable_oid[] = { 1, 3, 6, 1, 2, 1, 16, 15, 5 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration    *my_handler;
    netsnmp_iterator_info	    *iinfo;

    /*
     * create the table structure itself
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
     */
    my_handler = netsnmp_create_handler_registration("nlMatrixTopNTable",
                                                     nlMatrixTopNTable_handler,
                                                     nlMatrixTopNTable_oid,
                                                     OID_LENGTH(nlMatrixTopNTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
				     ASN_INTEGER,   /* index: nlMatrixTopNControlIndex */
                                     ASN_INTEGER,       /* index: nlMatrixTopNIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 8;

    /*
     * iterator access routines
     */
    iinfo->get_first_data_point = nlMatrixTopNTable_get_first_data_point;
    iinfo->get_next_data_point = nlMatrixTopNTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_nlMatrixTopNTable",
                "Registering table nlMatrixTopNTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
#endif
}


/** Initialize the nlMatrixSDTable table by defining its contents and how it's structured */
void
initialize_table_nlMatrixSDTable(void)
{
    static oid nlMatrixSDTable_oid[] = { 1, 3, 6, 1, 2, 1, 16, 15, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration    *my_handler;
    netsnmp_iterator_info	    *iinfo;

    /*
     * create the table structure itself
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
     */
    my_handler = netsnmp_create_handler_registration("nlMatrixSDTable",
                                                     nlMatrixSDTable_handler,
                                                     nlMatrixSDTable_oid,
                                                     OID_LENGTH(nlMatrixSDTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
				     ASN_INTEGER,   /* index: hlMatrixControlIndex */
                                     ASN_TIMETICKS,     /* index: nlMatrixSDTimeMark */
                                     ASN_INTEGER,       /* index: protocolDirLocalIndex */
                                     ASN_OCTET_STR,     /* index: nlMatrixSDSourceAddress */
                                     ASN_OCTET_STR,     /* index: nlMatrixSDDestAddress */
                                     0);

    table_info->min_column = 4;
    table_info->max_column = 6;

    /*
     * iterator access routines
     */
    iinfo->get_first_data_point = nlMatrixSDTable_get_first_data_point;
    iinfo->get_next_data_point = nlMatrixSDTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_nlMatrixSDTable",
                "Registering table nlMatrixSDTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);

    snmp_log(LOG_INFO, "success: nlMatrixSD initialized\n");
}


/** Initialize the nlMatrixTopNControlTable table by defining its contents and how it's structured */
void
initialize_table_nlMatrixTopNControlTable(void)
{
#if 0
    static oid nlMatrixTopNControlTable_oid[] = { 1, 3, 6, 1, 2, 1, 16, 15, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration    *my_handler;
    netsnmp_iterator_info	    *iinfo;

    /*
     * create the table structure itself
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
     */
    my_handler =
        netsnmp_create_handler_registration("nlMatrixTopNControlTable",
                                            nlMatrixTopNControlTable_handler,
                                            nlMatrixTopNControlTable_oid,
                                            OID_LENGTH(nlMatrixTopNControlTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
				     ASN_INTEGER,   /* index: nlMatrixTopNControlIndex */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 11;

    /*
     * iterator access routines
     */
    iinfo->get_first_data_point =
        nlMatrixTopNControlTable_get_first_data_point;
    iinfo->get_next_data_point =
        nlMatrixTopNControlTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_nlMatrixTopNControlTable",
                "Registering table nlMatrixTopNControlTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
#endif
}


/** Initializes the nlMatrix module */
void
init_nlMatrix(void)
{

    /*
     * here we initialize all the tables we're planning on supporting
     */
    initialize_table_hlMatrixControlTable();
    initialize_table_nlMatrixDSTable();
//    initialize_table_nlMatrixTopNTable();
    initialize_table_nlMatrixSDTable();
//    initialize_table_nlMatrixTopNControlTable();
}


/** returns the first data point within the hlMatrixControlTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
hlMatrixControlTable_get_first_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list   *vptr;
    unsigned int	    indice;

    if (hlmatrix_tabela_prepara(&indice) != SUCCESS) {
	return NULL;
    }

    *my_loop_context = (void *)indice;
    *my_data_context = (void *)indice;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&indice, sizeof(indice));
    vptr = vptr->next_variable;

    return put_index_data;
}


/** functionally the same as hlMatrixControlTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
hlMatrixControlTable_get_next_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *put_index_data,
                                         netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list   *vptr;
    unsigned int	    indice;

    if (hlmatrix_tabela_proximo(&indice) != SUCCESS) {
	return NULL;
    }

    *my_loop_context = (void *)indice;
    *my_data_context = (void *)indice;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&indice, sizeof(indice));
    vptr = vptr->next_variable;

    return put_index_data;
}


/** handles requests for the hlMatrixControlTable table, if anything else needs to be done */
int
hlMatrixControlTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /* IF-MIB::ifIndex.n == .1.3.6.1.2.1.2.2.1.1.n */
    char			buffer[64];
    oid                         ifindex_oid[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0};
    netsnmp_request_info	*request;
    netsnmp_table_request_info	*table_info;
    netsnmp_variable_list	*var;
    unsigned int		indice;
    uint32_t			valor;
    int32_t			valor_s;
    char			*char_ptr;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed.
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the hlMatrixControlTable table in question
         */
	indice = (unsigned int)netsnmp_extract_iterator_context(request);
        if (hlmatrix_getRowstatus(indice) < 0) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue
             */
        }

	ifindex_oid[10] = (oid)indice;

        /*
         * extracts the information about the table from the request
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_HLMATRIXCONTROLDATASOURCE:
                snmp_set_var_typed_value(var, ASN_OBJECT_ID, (u_char *)ifindex_oid,
			sizeof(ifindex_oid));
                break;

            case COLUMN_HLMATRIXCONTROLNLDROPPEDFRAMES:
		if (hlmatrix_getNlDroppedFrames(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_COUNTER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_HLMATRIXCONTROLNLINSERTS:
		if (hlmatrix_getNlInserts(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_COUNTER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_HLMATRIXCONTROLNLDELETES:
		if (hlmatrix_getNlDeletes(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_COUNTER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_HLMATRIXCONTROLNLMAXDESIREDENTRIES:
		if (hlmatrix_getNlMaxentries(indice, &valor_s) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_INTEGER, (u_char *)&valor_s, sizeof(valor_s));
                break;

            case COLUMN_HLMATRIXCONTROLALDROPPEDFRAMES:
		if (hlmatrix_getAlDroppedFrames(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_COUNTER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_HLMATRIXCONTROLALINSERTS:
		if (hlmatrix_getAlInserts(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_COUNTER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_HLMATRIXCONTROLALDELETES:
		if (hlmatrix_getAlDeletes(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_COUNTER, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_HLMATRIXCONTROLALMAXDESIREDENTRIES:
		if (hlmatrix_getAlMaxentries(indice, &valor_s) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_INTEGER, (u_char *)&valor_s, sizeof(valor_s));
                break;

            case COLUMN_HLMATRIXCONTROLOWNER:
		valor_s = hlmatrix_busca_owner(indice, buffer, sizeof(buffer));
		if (valor_s > 0) {
		    snmp_set_var_typed_value(var, ASN_OCTET_STR, (u_char *)char_ptr,
			    valor_s);
		}
		else {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}

                break;

            case COLUMN_HLMATRIXCONTROLSTATUS:
		valor_s = hlmatrix_getRowstatus(indice);
		if (valor_s < 0) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    return SNMP_ERR_NOSUCHNAME;
		}
                snmp_set_var_typed_value(var, ASN_INTEGER, (u_char *)&valor_s, sizeof(valor_s));
                break;

            default:
                /*
                 * We shouldn't get here
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in hlMatrixControlTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling...
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in hlMatrixControlTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}


/** returns the first data point within the nlMatrixDSTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
nlMatrixDSTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list   *vptr;
    uint32_t		    indice;
    uint32_t		    tripa[5];

    if (nlmatrix_ds_tabela_prepara(&indice) != SUCCESS) {
	return NULL;
    }

    if (nlmatrix_ds_helper(indice, tripa) != SUCCESS) {
	return NULL;
    }

    *my_loop_context = (void *)indice;
    *my_data_context = (void *)indice;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&tripa[0], sizeof(uint32_t));

    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *)&tripa[1], sizeof(uint32_t));

    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *)&tripa[2], sizeof(uint32_t));

    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *)&tripa[3], sizeof(uint32_t));

    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *)&tripa[4], sizeof(uint32_t));

    vptr = vptr->next_variable;

    return put_index_data;
}


/** functionally the same as nlMatrixDSTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
nlMatrixDSTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list *put_index_data,
                                    netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list   *vptr;
    uint32_t		    indice;
    uint32_t		    tripa[5];

    if (nlmatrix_ds_tabela_proximo(&indice) != SUCCESS) {
	return NULL;
    }

    if (nlmatrix_ds_helper(indice, tripa) != SUCCESS) {
	return NULL;
    }

    *my_loop_context = (void *)indice;
    *my_data_context = (void *)indice;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&tripa[0], sizeof(uint32_t));

    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *)&tripa[1], sizeof(uint32_t));

    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *)&tripa[2], sizeof(uint32_t));

    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *)&tripa[3], sizeof(uint32_t));

    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *)&tripa[4], sizeof(uint32_t));

    vptr = vptr->next_variable;

    return put_index_data;
}


/** handles requests for the nlMatrixDSTable table, if anything else needs to be done */
int
nlMatrixDSTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    netsnmp_request_info	*request;
    netsnmp_table_request_info	*table_info;
    netsnmp_variable_list	*var;
    uint32_t			indice;
    uint32_t			valor;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed.
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the nlMatrixDSTable table in question
         */
	indice = (uint32_t)netsnmp_extract_iterator_context(request);
        if (nlmatrix_ds_testa(indice) != SUCCESS) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue
             */

	    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOCREATION);
	    return SNMP_ERR_NOCREATION;
        }

        /*
         * extracts the information about the table from the request
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_NLMATRIXDSPKTS:
		if (nlmatrix_ds_busca_pkts(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
		    return SNMP_NOSUCHINSTANCE;
		}
                snmp_set_var_typed_value(var, ASN_GAUGE, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_NLMATRIXDSOCTETS:
		if (nlmatrix_ds_busca_octets(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
		    return SNMP_NOSUCHINSTANCE;
		}
                snmp_set_var_typed_value(var, ASN_GAUGE, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_NLMATRIXDSCREATETIME:
		if (nlmatrix_ds_busca_createtime(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
		    return SNMP_NOSUCHINSTANCE;
		}
                snmp_set_var_typed_value(var, ASN_TIMETICKS, (u_char *)&valor, sizeof(valor));
                break;

            default:
                /*
                 * We shouldn't get here
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in nlMatrixDSTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling...
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in nlMatrixDSTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}


/** returns the first data point within the nlMatrixTopNTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
nlMatrixTopNTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    return NULL;
#if 0
    netsnmp_variable_list *vptr;

    *my_loop_context = /* XXX */ ;
    *my_data_context = /* XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) /* XXX: nlMatrixTopNControlIndex data */
                       , /* XXX: length of nlMatrixTopNControlIndex data */
                       );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /* XXX: nlMatrixTopNIndex data */ ,
                       /* XXX: length of nlMatrixTopNIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
#endif
}


/** functionally the same as nlMatrixTopNTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
nlMatrixTopNTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    return NULL;
#if 0
    netsnmp_variable_list *vptr;

    *my_loop_context = /* XXX */ ;
    *my_data_context = /* XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) /* XXX: nlMatrixTopNControlIndex data */
                       , /* XXX: length of nlMatrixTopNControlIndex data */
                       );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /* XXX: nlMatrixTopNIndex data */ ,
                       /* XXX: length of nlMatrixTopNIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
#endif
}


/** handles requests for the nlMatrixTopNTable table, if anything else needs to be done */
int
nlMatrixTopNTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
#if 0
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed.
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the nlMatrixTopNTable table in question
         */
        /*
         * XXX
         */  = ( /* XXX */ *)netsnmp_extract_iterator_context(request);
        if ( /* XXX */  == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue
             */
        }

        /*
         * extracts the information about the table from the request
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_NLMATRIXTOPNPROTOCOLDIRLOCALINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNSOURCEADDRESS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNDESTADDRESS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNPKTRATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNREVERSEPKTRATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNOCTETRATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNREVERSEOCTETRATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            default:
                /*
                 * We shouldn't get here
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in nlMatrixTopNTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling...
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in nlMatrixTopNTable_handler: unsupported mode\n");
        }
    }
#endif
    return SNMP_ERR_NOERROR;
}


/** returns the first data point within the nlMatrixSDTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
nlMatrixSDTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list   *vptr;
    uint32_t		    indice;
    uint32_t		    tripa[5];

    if (nlmatrix_sd_tabela_prepara(&indice) != SUCCESS) {
	return NULL;
    }

    if (nlmatrix_sd_helper(indice, tripa) != SUCCESS) {
	return NULL;
    }

    *my_loop_context = (void *)indice;
    *my_data_context = (void *)indice;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&tripa[0], sizeof(uint32_t));
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)&tripa[1], sizeof(uint32_t));
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)&tripa[2], sizeof(uint32_t));
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)&tripa[3], sizeof(uint32_t));
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)&tripa[4], sizeof(uint32_t));
    vptr = vptr->next_variable;

    return put_index_data;
}


/** functionally the same as nlMatrixSDTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
nlMatrixSDTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list *put_index_data,
                                    netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list   *vptr;
    uint32_t		    indice;
    uint32_t		    tripa[5];

    if (nlmatrix_sd_tabela_proximo(&indice) != SUCCESS) {
	return NULL;
    }

    if (nlmatrix_sd_helper(indice, tripa) != SUCCESS) {
	return NULL;
    }

    *my_loop_context = (void *)indice;
    *my_data_context = (void *)indice;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&tripa[0], sizeof(uint32_t));
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)&tripa[1], sizeof(uint32_t));
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)&tripa[2], sizeof(uint32_t));
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)&tripa[3], sizeof(uint32_t));
    vptr = vptr->next_variable;

    snmp_set_var_value(vptr, (u_char *)&tripa[4], sizeof(uint32_t));
    vptr = vptr->next_variable;

    return put_index_data;
}


/** handles requests for the nlMatrixSDTable table, if anything else needs to be done */
int
nlMatrixSDTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    netsnmp_request_info	*request;
    netsnmp_table_request_info	*table_info;
    netsnmp_variable_list	*var;
    uint32_t			indice;
    uint32_t			valor;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed.
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the nlMatrixSDTable table in question
         */

	indice = (uint32_t)netsnmp_extract_iterator_context(request);
        if (nlmatrix_sd_testa(indice) != SUCCESS) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue
             */

	    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOCREATION);
	    return SNMP_ERR_NOCREATION;
        }

        /*
         * extracts the information about the table from the request
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_NLMATRIXSDPKTS:
		if (nlmatrix_sd_busca_pkts(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
		    return SNMP_NOSUCHINSTANCE;
		}
                snmp_set_var_typed_value(var, ASN_GAUGE, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_NLMATRIXSDOCTETS:
		if (nlmatrix_sd_busca_octets(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
		    return SNMP_NOSUCHINSTANCE;
		}
                snmp_set_var_typed_value(var, ASN_GAUGE, (u_char *)&valor, sizeof(valor));
                break;

            case COLUMN_NLMATRIXSDCREATETIME:
		if (nlmatrix_sd_busca_createtime(indice, &valor) != SUCCESS) {
		    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
		    return SNMP_NOSUCHINSTANCE;
		}
                snmp_set_var_typed_value(var, ASN_TIMETICKS, (u_char *)&valor, sizeof(valor));
                break;

            default:
                /*
                 * We shouldn't get here
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in nlMatrixSDTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling...
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in nlMatrixSDTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}


/** returns the first data point within the nlMatrixTopNControlTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
nlMatrixTopNControlTable_get_first_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *put_index_data,
                                              netsnmp_iterator_info *mydata)
{
    return NULL;
#if 0
    netsnmp_variable_list *vptr;

    *my_loop_context = /* XXX */ ;
    *my_data_context = /* XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) /* XXX: nlMatrixTopNControlIndex data */
                       , /* XXX: length of nlMatrixTopNControlIndex data */
                       );
    vptr = vptr->next_variable;

    return put_index_data;
#endif
}


/** functionally the same as nlMatrixTopNControlTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
nlMatrixTopNControlTable_get_next_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *put_index_data,
                                             netsnmp_iterator_info *mydata)
{
    return NULL;
#if 0
    netsnmp_variable_list *vptr;

    *my_loop_context = /* XXX */ ;
    *my_data_context = /* XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) /* XXX: nlMatrixTopNControlIndex data */
                       , /* XXX: length of nlMatrixTopNControlIndex data */
                       );
    vptr = vptr->next_variable;

    return put_index_data;
#endif
}


/** handles requests for the nlMatrixTopNControlTable table, if anything else needs to be done */
int
nlMatrixTopNControlTable_handler(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
#if 0
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed.
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the nlMatrixTopNControlTable table in question
         */
        /*
         * XXX
         */  = ( /* XXX */ *)netsnmp_extract_iterator_context(request);
        if ( /* XXX */  == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue
             */
        }

        /*
         * extracts the information about the table from the request
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_NLMATRIXTOPNCONTROLMATRIXINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLRATEBASE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLTIMEREMAINING:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLGENERATEDREPORTS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLDURATION:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLREQUESTEDSIZE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLGRANTEDSIZE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLSTARTTIME:
                snmp_set_var_typed_value(var, ASN_TIMETICKS,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLOWNER:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            case COLUMN_NLMATRIXTOPNCONTROLSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /* XXX: column data */
                                         , /* XXX: column data length */ );
                break;

            default:
                /*
                 * We shouldn't get here
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in nlMatrixTopNControlTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling...
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in nlMatrixTopNControlTable_handler: unsupported mode\n");
        }
    }
#endif
    return SNMP_ERR_NOERROR;
}

